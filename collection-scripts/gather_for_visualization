#!/bin/bash

#Safeguards
set -o nounset
set -o errexit
set -o pipefail

source "$(dirname "$0")"/monitoring_common.sh
source $(dirname "$0")/common.sh
get_mintime

ALERT_COLLECTION_PATH="/must-gather/monitoring/alert_metrics"
mkdir -p ${ALERT_COLLECTION_PATH}

# Store PIDs of all the subprocesses
pids=()

# etcd and alert metrics
echo "INFO: Getting etcd and alert metrics"
METRIC_MATCHES=(
    '--match=etcd_disk_wal_fsync_duration_seconds_bucket{job=~".*etcd.*"}'
    '--match=etcd_network_peer_sent_failures_total{job=~".*etcd.*"}'
    '--match=etcd_network_peer_round_trip_time_seconds_bucket{job=~".*etcd.*"}'
    '--match=etcd_server_proposals_failed_total{job=~".*etcd.*"}'
    '--match=etcd_disk_backend_commit_duration_seconds_bucket{job=~".*etcd.*"}'
    '--match=grpc_server_handling_seconds_bucket{job=~".*etcd.*", grpc_method!="Defragment", grpc_type="unary"}'
    '--match=grpc_server_handled_total{job=~".*etcd.*"}'
    '--match=ALERTS{}'
    '--match=ALERTS_FOR_STATE{}'
)
METRICS_PATH=${ALERT_COLLECTION_PATH} metrics_get --min-time="${MIN_TIME}" "${METRIC_MATCHES[@]}" &
pids+=($!)

# Gather audit logs from API server
/usr/bin/gather_audit_logs &
pids+=($!)

# Check if PID array has any values, if so, wait for them to finish
if [ ${#pids[@]} -ne 0 ]; then
    echo "Waiting on subprocesses to finish execution."
    wait "${pids[@]}"
fi

# Force disk flush to ensure that all data gathered is accessible in the copy container
sync
